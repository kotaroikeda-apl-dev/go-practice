# Worker Pool

## 概要

Worker Pool は、限られた数のワーカー（goroutine）で大量のジョブを効率的に処理する並行処理パターンです。  
複数の worker goroutine が jobs チャネルからジョブを受け取り、並列で処理して results チャネルに結果を送信します。  
これにより、リソースを制御しながら並行処理のパフォーマンスを向上させることができます。

## 実行方法

```bash
cd concurrency/workerpool
go run main.go
```

## 処理の流れ

```
main 関数
  │
  ├─> jobs チャネル（バッファ付き）
  │     │
  │     ├─> [1] [2] [3] ... [10]  ← ジョブを投入
  │     │
  │     └─> close(jobs)           ← これ以上送信しないことを通知
  │
  ├─> Worker #1 ──┐
  ├─> Worker #2 ──┤
  └─> Worker #3 ──┘
         │
         ├─> jobs チャネルからジョブを受信
         ├─> 処理（100ms待機 + 2倍にする）
         └─> results チャネルに結果を送信
              │
              └─> main 関数が results から受信
```

**処理のステップ：**

1. **準備**: `jobs`チャネルと`results`チャネルを作成
2. **ワーカー起動**: 3 つのワーカーを goroutine として起動
3. **ジョブ投入**: 1〜10 のジョブを`jobs`チャネルに送信
4. **チャネルを閉じる**: `close(jobs)`で「これ以上ジョブはない」ことを通知
5. **結果を受信**: `results`チャネルから 10 個の結果を受信
6. **終了待ち**: WaitGroup で全てのワーカーの終了を待つ

## コードのポイント

### worker 関数の役割

`worker`関数は、goroutine として実行され、`jobs`チャネルからジョブを受け取って処理します。

```go
func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    for j := range jobs {
        // ジョブを処理
        result := j * 2
        results <- result
    }
}
```

- `for j := range jobs`で、`jobs`チャネルからジョブを受信し続けます
- `jobs`チャネルが`close`されると、`range`ループが自動的に終了します
- `defer wg.Done()`で、ワーカーが終了したことを WaitGroup に通知します

### sync.WaitGroup を使っている理由

`sync.WaitGroup`は、複数の goroutine の終了を待つための同期プリミティブです。

- `wg.Add(1)`: ワーカーを起動する前に、WaitGroup のカウンターを増やします
- `wg.Done()`: ワーカーが終了する時に、カウンターを減らします（`defer`で確実に実行）
- `wg.Wait()`: カウンターが 0 になるまで待機します

これにより、全てのワーカーが処理を完了してから、プログラムが終了することを保証できます。

### close(jobs) が重要な理由

`close(jobs)`を呼ぶことで、ワーカー側の`for range`ループに「これ以上ジョブはない」ことを通知します。

- `close(jobs)`を呼んでも、すでにチャネル内にあるジョブや処理中のジョブには影響しません
- チャネル内の全てのジョブを受信し終わると、`for range`ループが終了します
- `close`しないと、ワーカーは新しいジョブを待ち続けてしまい、デッドロックが発生する可能性があります

### range jobs でチャネルがクローズされるとループが終了すること

`for j := range jobs`は、`jobs`チャネルが`close`されると自動的にループを終了します。

- チャネル内に残っているジョブは全て受信されます
- 全て受信し終わると、次のループで`range`が終了します
- これにより、ワーカーは適切に終了できます

## 学べること

### goroutine の基本

- `go`キーワードで goroutine を起動する方法
- 複数の goroutine が並行して実行される様子
- goroutine 間でのデータの受け渡し

### channel を使った仕事の割り振り

- `jobs`チャネルでジョブを送信し、ワーカーが受信するパターン
- `results`チャネルで処理結果を集約するパターン
- バッファ付きチャネルの使い方

### WaitGroup による goroutine の終了待ち

- 複数の goroutine の終了を待つ方法
- `defer`を使った確実な`Done()`の呼び出し
- 同期処理の重要性

### Worker Pool パターンの応用先

- **Web API の並列呼び出し**: 複数の API エンドポイントに並列でリクエストを送信
- **バッチ処理**: 大量のデータを効率的に処理
- **ファイル処理**: 複数のファイルを並列で読み込み・処理
- **データベースクエリ**: 複数のクエリを並列で実行

## まとめ

Worker Pool パターンは、Go の並行処理を学ぶ上で重要なパターンです。  
限られた数のワーカーで大量のジョブを効率的に処理することで、リソースを制御しながら並行処理のパフォーマンスを向上させることができます。  
このサンプルコードを通じて、goroutine、channel、WaitGroup の基本的な使い方を理解できるはずです。
