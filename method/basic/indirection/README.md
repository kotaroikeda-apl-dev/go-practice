# メソッドとポインタの間接参照

このディレクトリでは、ポインタ引数を持つ関数とポインタレシーバーを持つメソッドの呼び出し方の違いを学びます。

## 重要なポイント

### 1. ポインタ引数を持つ関数

ポインタ引数を持つ関数は、**必ずポインタを明示的に渡す必要があります**。

```go
func MoveByFunc(p *Point, dx, dy float64) {
    p.X = p.X + dx
    p.Y = p.Y + dy
}

var v Point
MoveByFunc(v, 5, 3)    // ❌ コンパイルエラー！
MoveByFunc(&v, 5, 3)   // ✅ OK
```

### 2. ポインタレシーバーを持つメソッド

ポインタレシーバーを持つメソッドは、**値でもポインタでも呼び出せます**。Go が自動的に変換してくれます。

```go
func (p *Point) MoveByMethod(dx, dy float64) {
    p.X = p.X + dx
    p.Y = p.Y + dy
}

var v Point
v.MoveByMethod(5, 3)   // ✅ OK（Goが自動的に(&v).MoveByMethod(5, 3)に変換）
p := &v
p.MoveByMethod(10, 2)  // ✅ OK
```

## なぜこの違いがあるのか？

### 関数の場合

- 関数は型の一部ではないため、引数の型が厳密に一致する必要がある
- `MoveByFunc(v, 5, 3)`は型が合わないためエラーになる

### メソッドの場合

- メソッドは型に属しているため、Go が利便性のために自動変換を行う
- `v.MoveByMethod(5, 3)`は`(&v).MoveByMethod(5, 3)`として解釈される

## まとめ

| 呼び出し方法         | ポインタ引数の関数 | ポインタレシーバーのメソッド |
| -------------------- | ------------------ | ---------------------------- |
| 値から呼び出す       | ❌ エラー          | ✅ OK（自動変換）            |
| ポインタから呼び出す | ✅ OK              | ✅ OK                        |

この違いを理解することで、Go のメソッドの便利さと、関数とメソッドの使い分けができるようになります。

## 実行方法

```bash
go run main.go
```

## 出力例

```
=== メソッドとポインタの間接参照 ===

【ケース1: 値から呼び出す】
初期値: {X:3 Y:4}
v.MoveByMethod(2, 1)後: {X:5 Y:5}
MoveByFunc(&v, 5, 3)後: {X:10 Y:8}

【ケース2: ポインタから呼び出す】
初期値: &{X:4 Y:3}
p.MoveByMethod(-1, 2)後: &{X:3 Y:5}
MoveByFunc(p, 3, -1)後: &{X:6 Y:4}
```
