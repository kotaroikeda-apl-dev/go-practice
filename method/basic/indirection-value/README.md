# メソッドとポインタの間接参照（値レシーバー編）

このディレクトリでは、値引数を持つ関数と値レシーバーを持つメソッドの呼び出し方の違いを学びます。

## 重要なポイント

### 1. 値引数を持つ関数

値引数を持つ関数は、**必ず値を明示的に渡す必要があります**。

```go
func LengthByFunc(p Point) float64 {
    return math.Sqrt(p.X*p.X + p.Y*p.Y)
}

var v Point
LengthByFunc(v)    // ✅ OK
p := &v
LengthByFunc(p)    // ❌ コンパイルエラー！
LengthByFunc(*p)   // ✅ OK（ポインタをデリファレンス）
```

### 2. 値レシーバーを持つメソッド

値レシーバーを持つメソッドは、**値でもポインタでも呼び出せます**。Go が自動的に変換してくれます。

```go
func (p Point) LengthByMethod() float64 {
    return math.Sqrt(p.X*p.X + p.Y*p.Y)
}

var v Point
v.LengthByMethod()  // ✅ OK
p := &v
p.LengthByMethod()  // ✅ OK（Goが自動的に(*p).LengthByMethod()に変換）
```

## なぜこの違いがあるのか？

### 関数の場合

- 関数は型の一部ではないため、引数の型が厳密に一致する必要がある
- `LengthByFunc(p)`は型が合わないためエラーになる（`p`は`*Point`型だが、関数は`Point`型を期待）

### メソッドの場合

- メソッドは型に属しているため、Go が利便性のために自動変換を行う
- `p.LengthByMethod()`は`(*p).LengthByMethod()`として解釈される

## まとめ

| 呼び出し方法         | 値引数の関数 | 値レシーバーのメソッド |
| -------------------- | ------------ | ---------------------- |
| 値から呼び出す       | ✅ OK        | ✅ OK                  |
| ポインタから呼び出す | ❌ エラー    | ✅ OK（自動変換）      |

## ポインタレシーバー編との対比

| 呼び出し方法         | ポインタ引数の関数 | ポインタレシーバーのメソッド | 値引数の関数 | 値レシーバーのメソッド |
| -------------------- | ------------------ | ---------------------------- | ------------ | ---------------------- |
| 値から呼び出す       | ❌ エラー          | ✅ OK（自動変換）            | ✅ OK        | ✅ OK                  |
| ポインタから呼び出す | ✅ OK              | ✅ OK                        | ❌ エラー    | ✅ OK（自動変換）      |

この違いを理解することで、Go のメソッドの便利さと、関数とメソッドの使い分けができるようになります。

## 実行方法

```bash
go run main.go
```

## 出力例

```
=== メソッドとポインタの間接参照（値レシーバー編） ===

【ケース1: 値から呼び出す】
初期値: {X:3 Y:4}
v.LengthByMethod() = 5.00
LengthByFunc(v) = 5.00

【ケース2: ポインタから呼び出す】
初期値: &{X:4 Y:3}
p.LengthByMethod() = 5.00
LengthByFunc(*p) = 5.00
```
